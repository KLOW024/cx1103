#include <stdio.h>
#include <math.h>

struct circle {
    double radius;
    double x;
    double y;
};

int intersect(struct circle c1, struct circle c2);
int contain(struct circle *c1, struct circle *c2);

int main() {
    struct circle c1 = {5, 3,4}, *a = &c1;
    struct circle c2 = {10, 5, 3},*b = &c2; 
    printf("%d", contain(b,a));
      
}

int intersect(struct circle c1, struct circle c2){
    double dist;
    dist = sqrt(pow(c2.y-c1.y, 2)+pow(c2.x-c1.x, 2));
    if(dist <= (c1.radius+c2.radius)){
        return 1;
    }
    else return 0;
}//doesnt check if it contains 

int contain(struct circle *c1, struct circle *c2){
    double distx, disty, dist;
    distx = (c1->x) - (c2->x);
    disty = (c1->y) - (c2->y);
    dist = sqrt(pow(distx,2) + pow(disty,2));
    if(c1->radius >= (c2->radius + dist)){
        return 1;
    } else return 0;

}

//qn2
#include <stdio.h>
#include <math.h>

typedef struct {
float operand1, operand2;
char op;    /* operator ‘+’,‘‐’,‘*’ or ‘/’  */
} bexpression;

float compute1(bexpression expr);
float compute2(bexpression *expr);

int main() {
    bexpression C = {9, 3, '/'};
    printf("%.5f\n", compute1(C));
    struct bexpression *a = &C;
    printf("%.5f", compute2(a)); 
}

float compute1(bexpression expr){
    switch(expr.op){
        case '+': return expr.operand1 + expr.operand2; 
        case '-': return expr.operand1 - expr.operand2;
        case '*': return expr.operand1 * expr.operand2;
        case '/': return expr.operand1 / expr.operand2;
    }
}

float compute2(bexpression *expr){
    switch(expr -> op){
        case '+': return expr -> operand1 + expr -> operand2; 
        case '-': return expr -> operand1 - expr -> operand2;
        case '*': return expr -> operand1 * expr -> operand2;
        case '/': return expr -> operand1 / expr -> operand2;
    }
}
